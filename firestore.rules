// firestore.rules â€” Part C+D+E+F
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------- Helpers ---------
    function isSignedIn() {
      return request.auth != null;
    }
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    function isAdmin() {
      return isSignedIn() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }
    // Small utilities
    function hasOnlyKeys(allowed) {
      return request.resource.data.keys().hasOnly(allowed);
    }
    function hasAllKeys(required) {
      return request.resource.data.keys().hasAll(required);
    }

    // ===========================
    //  USERS (profiles)  (C)
    // ===========================
    match /users/{userId} {
      // READ: owner or admin directory
      allow read: if isOwner(userId) || isAdmin();

      // WRITE: only the owner (admins do not edit profile directly)
      allow create, update, delete: if isOwner(userId)
        && usersSchemaOK();

      // Minimal schema enforcement
      function usersSchemaOK() {
        return (
          // Allowed keys only (add fields here if you extend the doc)
          hasOnlyKeys([
            'email','username','firstName','lastName','age','location','gender',
            'reason','role','createdAt','updatedAt','provider'
          ]) ||
          // allow merge updates that don't include all fields
          true
        )
        &&
        (
          !('email' in request.resource.data)    || request.resource.data.email is string
        ) &&
        (
          !('username' in request.resource.data) || request.resource.data.username is string
        ) &&
        (
          !('firstName' in request.resource.data)|| request.resource.data.firstName is string
        ) &&
        (
          !('lastName' in request.resource.data) || request.resource.data.lastName is string
        ) &&
        (
          !('age' in request.resource.data)      || request.resource.data.age is int
        ) &&
        (
          !('location' in request.resource.data) || request.resource.data.location is string
        ) &&
        (
          !('gender' in request.resource.data)   || request.resource.data.gender is string
        ) &&
        (
          !('reason' in request.resource.data)   || request.resource.data.reason is string
        ) &&
        (
          !('role' in request.resource.data)     || request.resource.data.role is string
        ) &&
        (
          !('provider' in request.resource.data) || request.resource.data.provider is string
        );
      }
    }

    // ==================================
    //  PROGRAMS catalog  (D.3 tables)
    // ==================================
    // Public can read programs; only admins manage them.
    match /programs/{programId} {
      allow read: if true;
      allow create, update, delete: if isAdmin() && programsSchemaOK();

      function programsSchemaOK() {
        return hasAllKeys(['title','type','days','address']) // core fields present on create
          && (
            hasOnlyKeys([
              'title','type','days','address','suburb','lat','lng',
              'price','capacity','description','createdAt','updatedAt','active'
            ]) || true
          )
          &&
          (request.resource.data.title is string)
          && (request.resource.data.type is string)
          && (request.resource.data.days is list)
          && (request.resource.data.address is string)
          && (!('suburb' in request.resource.data) || request.resource.data.suburb is string)
          && (!('lat' in request.resource.data)    || request.resource.data.lat is number)
          && (!('lng' in request.resource.data)    || request.resource.data.lng is number)
          && (!('price' in request.resource.data)  || request.resource.data.price is number)
          && (!('capacity' in request.resource.data) || request.resource.data.capacity is int)
          && (!('active' in request.resource.data) || request.resource.data.active is bool);
      }
    }

    // ==================================
    //  ENROLMENTS  (D.3 tables / future F)
    // ==================================
    // Users manage their own enrolments; admins can read for oversight.
    match /enrolments/{enrolId} {
      allow read: if isAdmin() || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && enrolSchemaOK();
      allow update, delete: if isSignedIn() && resource.data.uid == request.auth.uid && enrolSchemaOK();
      // Optional: allow admin status updates (comment in if you need)
      // allow update: if isAdmin() && enrolSchemaOK();

      function enrolSchemaOK() {
        return (
          hasOnlyKeys(['uid','programId','status','createdAt','notes']) || true
        )
        && (request.resource.data.uid is string)
        && (request.resource.data.programId is string)
        && (request.resource.data.status is string);
      }
    }

    // ==================================
    //  BOOKINGS (FullCalendar)  (F)
    // ==================================
    // Owner CRUD own bookings; admins can read/manage all.
    match /bookings/{bookingId} {
      allow read: if isAdmin() || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && bookingSchemaOK();
      allow update, delete: if (isSignedIn() && resource.data.uid == request.auth.uid || isAdmin())
        && bookingSchemaOK();

      function bookingSchemaOK() {
        return (
          hasOnlyKeys(['uid','programId','dateStart','dateEnd','status','createdAt']) || true
        )
        && (request.resource.data.uid is string)
        && (request.resource.data.programId is string)
        && (request.resource.data.dateStart is string) // ISO strings from client
        && (request.resource.data.dateEnd is string)
        && (request.resource.data.status is string);
      }
    }

    // ==================================
    //  RATINGS: SCORES (C.3 legacy)
    // ==================================
    match /ratings/{itemKey}/scores/{userId} {
      allow read: if true;
      allow create, update, delete: if isOwner(userId) && isValidScore();

      function isValidScore() {
        return hasOnlyKeys(['score','at'])
          && request.resource.data.score is int
          && request.resource.data.score >= 1
          && request.resource.data.score <= 5
          && request.resource.data.at is string;
      }
    }

    // ==================================
    //  RATINGS: REVIEWS (C.3 new)
    // ==================================
    match /ratings/{itemKey}/reviews/{userId} {
      allow read: if true;
      allow create, update, delete: if isOwner(userId) && isValidReview();

      function isValidReview() {
        return hasOnlyKeys(['score','comment','at'])
          && request.resource.data.score is int
          && request.resource.data.score >= 1
          && request.resource.data.score <= 5
          && request.resource.data.comment is string
          && request.resource.data.comment.size() >= 5
          && request.resource.data.comment.size() <= 500
          && request.resource.data.at is string;
      }
    }

    // Optional aggregate cache written by Cloud Function (E.1)
    match /ratingsMeta/{itemKey} {
      allow read: if true;
      allow write: if isAdmin(); // or allow only CF via App Check / Admin SDK
    }

    // ==================================
    //  EMAILS QUEUE (D.2 via CF + SendGrid)
    // ==================================
    // Admin writes "queued" emails; Cloud Function sends and updates status.
    match /emails/{emailId} {
      allow read, write: if isAdmin() && emailSchemaOK();

      function emailSchemaOK() {
        return (
          hasOnlyKeys(['to','subject','body','attachments','status','createdAt','sentAt','error']) || true
        )
        && (request.resource.data.to is list)
        && (request.resource.data.subject is string)
        && (request.resource.data.body is string)
        && (!('attachments' in request.resource.data) || request.resource.data.attachments is list)
        && (!('status' in request.resource.data) || request.resource.data.status is string);
      }
    }

    // ==================================
    //  ANALYTICS (written by CF)  (E.1/E/F)
    // ==================================
    // Publicly readable dashboards; only admin (or CF) writes.
    match /analytics/{collection}/{docId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ==================================
    //  USER GEO FAVOURITES (E.2 bonus)
    // ==================================
    // Users can save favourite clubs/venues under their uid.
    match /geofavs/{uid}/clubs/{clubId} {
      allow read, write: if isOwner(uid) && geofavSchemaOK();

      function geofavSchemaOK() {
        return (
          hasOnlyKeys(['name','lat','lng','addedAt','sport']) || true
        )
        && (request.resource.data.name is string)
        && (request.resource.data.lat is number)
        && (request.resource.data.lng is number);
      }
    }
  }
}
