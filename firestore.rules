// firestore.rules â€” Part C + D + E + F (final)
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------- Helpers ---------
    function isSignedIn() {
      return request.auth != null;
    }
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    function isAdmin() {
      return isSignedIn() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == "admin";
    }
    // Small utilities
    function hasOnlyKeys(allowed) {
      return request.resource.data.keys().hasOnly(allowed);
    }
    function hasAllKeys(required) {
      return request.resource.data.keys().hasAll(required);
    }

    // ===========================
    //  USERS (profiles)  (C)
    // ===========================
    match /users/{userId} {
      // READ: owner or admin directory
      allow read: if isOwner(userId) || isAdmin();

      // WRITE: only the owner (admins do not edit profile directly)
      allow create, update, delete: if isOwner(userId) && usersSchemaOK();

      // Minimal schema enforcement
      function usersSchemaOK() {
        return (
          // Allowed keys only (extend list if you add fields)
          hasOnlyKeys([
            'email','username','firstName','lastName','age','location','gender',
            'reason','role','createdAt','updatedAt','provider'
          ]) || true  // allow partial updates
        )
        &&
        (!('email' in request.resource.data)     || request.resource.data.email is string)
        && (!('username' in request.resource.data) || request.resource.data.username is string)
        && (!('firstName' in request.resource.data)|| request.resource.data.firstName is string)
        && (!('lastName' in request.resource.data) || request.resource.data.lastName is string)
        && (!('age' in request.resource.data)      || request.resource.data.age is int)
        && (!('location' in request.resource.data) || request.resource.data.location is string)
        && (!('gender' in request.resource.data)   || request.resource.data.gender is string)
        && (!('reason' in request.resource.data)   || request.resource.data.reason is string)
        && (!('role' in request.resource.data)     || request.resource.data.role is string)
        && (!('provider' in request.resource.data) || request.resource.data.provider is string);
      }
    }

    // ==================================
    //  PROGRAMS catalog  (D.3 tables)
    // ==================================
    // Public can read programs; only admins manage them.
    match /programs/{programId} {
      allow read: if true;
      allow create, update, delete: if isAdmin() && programsSchemaOK();

      function programsSchemaOK() {
        return hasAllKeys(['title','type','days','address']) // core fields must exist
          && (
            hasOnlyKeys([
              'title','type','days','address','suburb','lat','lng',
              'price','capacity','description','createdAt','updatedAt','active'
            ]) || true // allow partial updates
          )
          && (request.resource.data.title is string)
          && (request.resource.data.type is string)
          && (request.resource.data.days is list)
          && (request.resource.data.address is string)
          && (!('suburb' in request.resource.data)    || request.resource.data.suburb is string)
          // Firestore uses int/float. Accept either for coordinates/price.
          && (!('lat' in request.resource.data)       || request.resource.data.lat is float || request.resource.data.lat is int)
          && (!('lng' in request.resource.data)       || request.resource.data.lng is float || request.resource.data.lng is int)
          && (!('price' in request.resource.data)     || request.resource.data.price is float || request.resource.data.price is int)
          && (!('capacity' in request.resource.data)  || request.resource.data.capacity is int)
          && (!('active' in request.resource.data)    || request.resource.data.active is bool);
      }
    }

    // ==================================
    //  ENROLMENTS  (D.3 tables / future F)
    // ==================================
    // Users manage their own enrolments; admins can read for oversight.
    match /enrolments/{enrolId} {
      allow read: if isAdmin() || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && enrolSchemaOK();
      allow update, delete: if isSignedIn()
        && resource.data.uid == request.auth.uid
        && enrolSchemaOK();
      // If you want admins to update enrolments too, uncomment:
      // allow update: if isAdmin() && enrolSchemaOK();

      function enrolSchemaOK() {
        return (hasOnlyKeys(['uid','programId','status','createdAt','notes']) || true)
          && (request.resource.data.uid is string)
          && (request.resource.data.programId is string)
          && (request.resource.data.status is string);
      }
    }

    // ==================================
    //  BOOKINGS (FullCalendar)  (F)
    // ==================================
    // Owner CRUD own bookings; admins can read/manage all.
    match /bookings/{bookingId} {
      allow read: if isAdmin() || (isSignedIn() && resource.data.uid == request.auth.uid);
      allow create: if isSignedIn()
        && request.resource.data.uid == request.auth.uid
        && bookingSchemaOK();
      allow update, delete: if (isSignedIn() && resource.data.uid == request.auth.uid || isAdmin())
        && bookingSchemaOK();

      function bookingSchemaOK() {
        return (hasOnlyKeys(['uid','programId','dateStart','dateEnd','status','createdAt']) || true)
          && (request.resource.data.uid is string)
          && (request.resource.data.programId is string)
          && (request.resource.data.dateStart is string) // ISO string if sent from client
          && (request.resource.data.dateEnd is string)
          && (request.resource.data.status is string);
      }
    }

    // ==================================
    //  RATINGS: SCORES (C.3 legacy)
    // ==================================
    match /ratings/{itemKey}/scores/{userId} {
      allow read: if true;
      allow create, update, delete: if isOwner(userId) && isValidScore();

      function isValidScore() {
        return hasOnlyKeys(['score','at'])
          && request.resource.data.score is int
          && request.resource.data.score >= 1
          && request.resource.data.score <= 5
          && request.resource.data.at is string;
      }
    }

    // ==================================
    //  RATINGS: REVIEWS (C.3 new)
    // ==================================
    match /ratings/{itemKey}/reviews/{userId} {
      allow read: if true;
      allow create, update, delete: if isOwner(userId) && isValidReview();

      function isValidReview() {
        return hasOnlyKeys(['score','comment','at'])
          && request.resource.data.score is int
          && request.resource.data.score >= 1
          && request.resource.data.score <= 5
          && request.resource.data.comment is string
          && request.resource.data.comment.size() >= 5
          && request.resource.data.comment.size() <= 500
          && request.resource.data.at is string;
      }
    }

    // Optional aggregate cache written by Cloud Function (E.1)
    match /ratingsMeta/{itemKey} {
      allow read: if true;
      allow write: if isAdmin(); // or restrict to CF via custom claims/App Check
    }

    // ==================================
    //  EMAILS QUEUE (D.2 via CF + SendGrid)
    // ==================================
    // If you ever queue emails in Firestore; not used by Cloudflare function.
    match /emails/{emailId} {
      allow read, write: if isAdmin() && emailSchemaOK();

      function emailSchemaOK() {
        return (hasOnlyKeys(['to','subject','body','attachments','status','createdAt','sentAt','error']) || true)
          && (request.resource.data.to is list)
          && (request.resource.data.subject is string)
          && (request.resource.data.body is string)
          && (!('attachments' in request.resource.data) || request.resource.data.attachments is list)
          && (!('status' in request.resource.data) || request.resource.data.status is string);
      }
    }

    // ==================================
    //  ANALYTICS (written by CF)  (E.1/E/F)
    // ==================================
    match /analytics/{collection}/{docId} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ==================================
    //  USER GEO FAVOURITES (E.2 bonus)
    // ==================================
    match /geofavs/{uid}/clubs/{clubId} {
      allow read, write: if isOwner(uid) && geofavSchemaOK();

      function geofavSchemaOK() {
        return (hasOnlyKeys(['name','lat','lng','addedAt','sport']) || true)
          && (request.resource.data.name is string)
          && (request.resource.data.lat is float || request.resource.data.lat is int)
          && (request.resource.data.lng is float || request.resource.data.lng is int);
      }
    }
  }
}
